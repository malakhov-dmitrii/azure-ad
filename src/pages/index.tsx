import {
  Box,
  Button,
  Flex,
  Heading,
  Skeleton,
  Spacer,
  Text,
} from "@chakra-ui/react";
import axios from "axios";
import { isBrowser } from "framer-motion";
import { type GetServerSideProps, type NextPage } from "next";
import Head from "next/head";
import Link from "next/link";
import { useRouter } from "next/router";
import QueryString from "qs";
import { useEffect, useState } from "react";
import { toast } from "react-toastify";
import { env } from "~/env.mjs";
import { redis } from "~/server/db";
import { getBaseUrl } from "~/utils/api";

const authUri = `https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=33dce5ac-b19a-41a7-8937-280d22cd1af9&response_type=code&redirect_uri=${getBaseUrl()}&response_mode=query&scope=profile%20%20User.Read%20openid%20offline_access&state=12345&prompt=select_account`;
const logoutUri = `https://login.microsoftonline.com/common/oauth2/v2.0/logout?post_logout_redirect_uri=https://azure-ad.vercel.app`;

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const Home: NextPage = (props: {
  access_token: string;
  refresh_token: string;
}) => {
  const router = useRouter();
  const [accessToken, setAccessToken] = useState("");
  const [refreshToken, setRefreshToken] = useState("");

  const [userLoading, setUserLoading] = useState(false);
  const [tokenLoading, setTokenLoading] = useState(false);

  const [user, setUser] = useState({});

  const fetchUserClient = async () => {
    if (!accessToken) {
      alert("No access token");
      return;
    }
    setUserLoading(true);

    const user = await axios
      .get("https://graph.microsoft.com/v1.0/me", {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      })
      .catch((err) => {
        toast.error("Error fetching user (client side)");
        return null;
      });

    setUserLoading(false);
    if (!user) return;
    toast.success("Fetched user (client side)");

    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    setUser(user.data);
  };

  const fetchUserServer = async () => {
    if (!accessToken) {
      alert("No access token");
      return;
    }

    setUserLoading(true);

    const user = await axios
      .get("/api/user", {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      })
      .catch((err) => {
        toast.error("Error fetching user (server side)");
        return null;
      });

    setUserLoading(false);
    if (!user) return;
    toast.success("Fetched user (server side)");

    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    setUser(user.data);
  };

  const fetchRefreshToken = async () => {
    if (!accessToken) {
      alert("No access token");
      return;
    }
    setTokenLoading(true);

    const user = await axios
      .get("/api/token", {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      })
      .catch((e) => {
        toast.error("Error refreshing token");
        return null;
      });

    setTokenLoading(false);
    if (!user) return;

    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
    setAccessToken(user.data.access_token);
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
    localStorage.setItem("accessToken", user.data.access_token);

    toast.success("Access Token refreshed");
  };

  useEffect(() => {
    if (props.access_token && props.refresh_token) {
      localStorage.setItem("accessToken", props.access_token);
      localStorage.setItem("refreshToken", props.refresh_token);
      setAccessToken(props.access_token);
      setRefreshToken(props.refresh_token);
      void router.push("/");
    } else {
      const accessToken = localStorage.getItem("accessToken");
      const refreshToken = localStorage.getItem("refreshToken");
      if (
        accessToken &&
        refreshToken &&
        accessToken.length > 0 &&
        refreshToken.length > 0
      ) {
        setAccessToken(accessToken);
        setRefreshToken(refreshToken);
      }
    }
  }, []);

  const clearStorage = () => {
    localStorage.removeItem("accessToken");
    localStorage.removeItem("refreshToken");
    setAccessToken("");
    setRefreshToken("");
    setUser({});
    window.location.reload();
  };
  return (
    <>
      <Head>
        <title>Azure AD Demo</title>
        <meta name="description" content="Generated by create-t3-app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <Flex py={4} alignItems="center">
        <Flex gap={4} alignItems="center">
          <Link href="https://app.getpostman.com/run-collection/f77994d794bab767596d">
            <Button variant="link">Postman</Button>
          </Link>
          <Link href="https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow#refreshing-the-access-tokens">
            <Button variant="link">MS Docs</Button>
          </Link>
        </Flex>
        <Spacer />
        {!accessToken && (
          <Link href={authUri}>
            <Button variant={"solid"} colorScheme="blue">
              Sign In
            </Button>
          </Link>
        )}
        {accessToken && (
          <>
            <Button
              variant={"outline"}
              colorScheme="blue"
              onClick={clearStorage}
            >
              Reset Stored Tokens
            </Button>
            <Button
              ml={2}
              variant={"outline"}
              colorScheme="blue"
              onClick={() => {
                clearStorage();
                window.location.href = logoutUri;
              }}
            >
              Sign Out
            </Button>
          </>
        )}
      </Flex>

      <Box mt={4} overflowX="auto" p={2}>
        <Heading variant="h2">User data:</Heading>
        <Skeleton isLoaded={!userLoading} minH={32} mb={4} rounded="md">
          <pre>{JSON.stringify(user, null, 2)}</pre>
        </Skeleton>

        <Button
          isLoading={userLoading}
          size="sm"
          colorScheme="blue"
          onClick={() => void fetchUserClient()}
          disabled={!accessToken}
        >
          Fetch User (Client)
        </Button>
        <Button
          ml={2}
          size="sm"
          colorScheme="blue"
          onClick={() => void fetchUserServer()}
          disabled={!accessToken}
          isLoading={userLoading}
        >
          Fetch User (Server)
        </Button>
      </Box>

      <Box mt={4} overflowX="auto" p={2}>
        <Heading variant="h2">Stored tokens:</Heading>

        <Skeleton isLoaded={!tokenLoading} minH={8} mb={4} rounded="md">
          <pre>
            {JSON.stringify(
              {
                accessToken,
                refreshToken,
              },
              null,
              2
            )}
          </pre>
        </Skeleton>
      </Box>
      <Button
        size="sm"
        colorScheme="blue"
        onClick={() => void fetchRefreshToken()}
        disabled={!accessToken}
        isLoading={tokenLoading}
      >
        Refresh Token
      </Button>
    </>
  );
};

export default Home;

export const getServerSideProps: GetServerSideProps = async (context) => {
  const code = context.query.code;

  if (!code) {
    return {
      props: {},
    };
  }

  const data = QueryString.stringify({
    client_id: "33dce5ac-b19a-41a7-8937-280d22cd1af9",
    scope: "https://graph.microsoft.com/mail.read",
    redirect_uri: getBaseUrl(),
    grant_type: "authorization_code",
    client_secret: process.env.CLIENT_SECRET,
    code,
  });

  const refresh = await axios
    .post("https://login.microsoftonline.com/common/oauth2/v2.0/token", data, {
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
    })
    .catch((e) => {
      console.log(e);
      return { data: {} };
    });

  if (!refresh.data) {
    return {
      redirect: {
        destination: "/",
      },
      props: {},
    };
  }

  const { access_token, refresh_token } = (refresh.data as {
    access_token: string;
    refresh_token: string;
  }) || {
    access_token: "",
    refresh_token: "",
  };

  void redis.set(access_token, refresh_token);

  return {
    props: {
      access_token,
      refresh_token,
    },
  };
};
